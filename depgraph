#!/usr/bin/perl

=head1 NAME

depgraph - Generate dependency graphs for C/C++

=head1 SYNOPSIS

B<depgraph> [B<options>] [[B<--pp-argv> I<arg>...] --] I<file>...

=head1 DESCRIPTION

B<depgraph> generates dependency graphs by preprocessing the gives I<file>s. It
writes the graph in some format to stdout. All input files are combined into one
graph.

=head1 OPTIONS

=over 7

=item B<--track-system>

Track dependencies of system header files, identified by the preprocessor or by
their path outside the local directory.

=item B<--no-track-system>

Ignore system headers and their dependencies. This is the default.

=item B<--local-dir> I<dir>

Set the directory of the project. If system headers are not tracked, then
non-relative include paths outside this directory are ignored.

=item B<--remove-built-in>

Try to ignore includes generated by the compiler, such as "<command line>" and
"<built-in>". This might not always being successful. This is the default.

=item B<--no-remove-built-in>

Keep compiler-generated includes.

=item B<--pretty-names>

Try to make file labels prettier by using the base names. This tries to infer
system headers by the presence of an 'include' directory in their path, but this
is no perfect heuristic. This does not apply with '--out-format json'.

=item B<--no-pretty-names>

Display header names as given by the preprocessor.

=item B<--out-format> I<format>

Output in the specified format. Currently this can be 'json' for a JSON
dictionary of headers and their dependencies, or 'dot' for a Graphvis directed
graph.

=item B<--pretty-dot>

This is a shortcut for '--pretty-names --out-format dot'.

=item B<--parallel> I<processes>

Use a number of parser processes equal to the positive number I<processes>. The
default is 8. This does not include the preprocessor processes.

=item B<--pp-argv>

This begins the argument vector with which to invoke the preprocessor. The
default is 'cc -E'. Note that the executable name must be specified, as it is
the zeroth argument. All arguments after this option up until the terminating
'--' are preprocessor arguments. After that, remaining arguments are input
files, so this must be the last option.

=item B<--help>

Display help information.

=item B<--version>

Display version.

=back

=head1 EXAMPLES

Invocation inside a Makefile:

depgraph --pp-argv $(CC) $(CFLAGS) -E -- $(source-files)

=head1 EXIT STATUS

Zero is the exit status unless something fails.

=head1 BUGS

Headers may have different dependencies on different includes, so some files may
have false dependencies since all includes of a file are squashed into one node.

Some includes are not mentioned at all by the preprocessor if they have already
been included. Fortunately, this does not produce false negatives.

=head1 AUTHOR

Written by Jude Melton-Houghton (jwmhjwmh@gmail.com).

=cut

use strict;
use warnings;

use constant INCFLAG_INCLUDE_FILE   => 1;
use constant INCFLAG_RETURN_TO_FILE => 2;
use constant INCFLAG_SYSTEM_HEADER  => 4;
use constant INCFLAG_EXTERN_C       => 8;

my $program_name = $0;
my $version      = '0.1.1'; # Change this with care; it must be detected by sed.
my $help_text;              # Initialized later.

sub main {
    my $opt_track_system    = 0;
    my $opt_local_dir       = '.';
    my $opt_remove_built_in = 1;
    my $opt_pretty_names    = 0;
    my $opt_out_format      = 'json';
    my $opt_parallel        = 8;
    my @opt_pp_argv         = ( 'cc', '-E' );
    while ( $#ARGV >= 0 ) {
        local ( $0, $1 );
        my $arg = shift @ARGV;
        if ( $arg eq '--track-system' ) {
            $opt_track_system = 1;
        }
        elsif ( $arg eq '--no-track-system' ) {
            $opt_track_system = 0;
        }
        elsif ( $arg eq '--local-dir' ) {
            fatal('Option --local-dir requires an argument') if ( $#ARGV < 0 );
            $opt_local_dir = shift @ARGV;
        }
        elsif ( $arg =~ /^--local-dir=(.*)$/ ) {
            $opt_local_dir = $1;
        }
        elsif ( $arg eq '--remove-built-in' ) {
            $opt_remove_built_in = 1;
        }
        elsif ( $arg eq '--no-remove-built-in' ) {
            $opt_remove_built_in = 0;
        }
        elsif ( $arg eq '--pretty-names' ) {
            $opt_pretty_names = 1;
        }
        elsif ( $arg eq '--no-pretty-names' ) {
            $opt_pretty_names = 0;
        }
        elsif ( $arg eq '--out-format' ) {
            fatal('Option --out-format requires an argument') if ( $#ARGV < 0 );
            $opt_out_format = shift @ARGV;
        }
        elsif ( $arg =~ /^--out-format=(.*)$/ ) {
            $opt_out_format = $1;
        }
        elsif ( $arg eq '--pretty-dot' ) {
            $opt_pretty_names = 1;
            $opt_out_format   = 'dot';
        }
        elsif ( $arg eq '--parallel' ) {
            $opt_parallel = shift @ARGV;
        }
        elsif ( $arg =~ /^--parallel=(.*)$/ ) {
            $opt_parallel = $1;
        }
        elsif ( $arg eq '--pp-argv' ) {
            @opt_pp_argv = ();
            while ( $#ARGV >= 0 && ( $arg = shift @ARGV ) ne '--' ) {
                push @opt_pp_argv, $arg;
            }
            last;
        }
        elsif ( $arg eq '--help' || $arg eq '-h' || $arg eq '-?' ) {
            print $help_text;
            exit 0;
        }
        elsif ( $arg eq '--version' || $arg eq '-v' ) {
            print "$program_name version $version\n";
            exit 0;
        }
        elsif ( $arg eq '--' ) {
            last;
        }
        elsif ( $arg =~ /^-./ ) {
            fatal("Unknown option: $arg");
        }
        else {
            unshift @ARGV, $arg;
            last;
        }
    }
    $opt_local_dir .= '/';
    fatal("Invalid process count: $opt_parallel")
      unless ( $opt_parallel =~ /^[0-9]+$/ && +$opt_parallel > 0 );

    my %deps           = ();
    my $num_procs      = +$opt_parallel;
    my $files_per_proc = int( scalar @ARGV / $num_procs );
    my $extra_files    = scalar @ARGV - $num_procs * $files_per_proc;
    my @readers        = ();
    while ( scalar @ARGV > $files_per_proc ) {
        pipe( my $reader, my $writer );
        push @readers, $reader;
        my $num_files = $files_per_proc + ( $extra_files-- > 0 );
        if ( fork() == 0 ) {
            foreach my $file ( @ARGV[ 0 .. $num_files - 1 ] ) {
                ( my $pp_out = start_preprocessor( \@opt_pp_argv, $file ) )
                  or fatal("Unable to start preprocessor; $!");
                scan_dependencies( \%deps, $pp_out, $opt_track_system,
                    $opt_local_dir );
            }
            trim_dependencies( \%deps, $opt_remove_built_in );
            write_dependencies( \%deps, $writer );
            exit 0;
        }
        else {
            close $writer;
            @ARGV = @ARGV[ $num_files .. $#ARGV ];
        }
    }
    foreach my $file (@ARGV) {
        ( my $pp_out = start_preprocessor( \@opt_pp_argv, $file ) )
          or fatal("Unable to start preprocessor; $!");
        scan_dependencies( \%deps, $pp_out, $opt_track_system, $opt_local_dir );
    }
    foreach my $reader (@readers) {
        read_dependencies( $reader, \%deps );
    }
    trim_dependencies( \%deps, $opt_remove_built_in );
    print_dependencies( \%deps, $opt_pretty_names, $opt_out_format );
}

$help_text = <<EOT;
Usage: $program_name [options] [[--pp-argv <arg>...] --] <file>...
Generate C/C++ dependency graphs using the C Preprocessor.
Options:
  --track-system
    Track dependencies of system header files, identified by the preprocessor or
    by their path outside the local directory.
  --no-track-system
    Ignore system headers and their dependencies. This is the default.
  --local-dir <dir>
    Set the directory of the project. If system headers are not tracked, then
    non-relative include paths outside this directory are ignored.
  --remove-built-in
    Try to ignore includes generated by the compiler, such as "<command line>"
    and "<built-in>". This might not always being successful.
    This is the default.
  --no-remove-built-in
    Keep compiler-generated includes.
  --pretty-names
    Try to make file labels prettier by using the base names. This tries to
    infer system headers by the presence of an 'include' directory in their
    path. This does not apply with '--out-format json'.
  --no-pretty-names
    Display header names as given by the preprocessor.
  --out-format <format>
    Output in the specified format. Currently this can be 'json' for a JSON
    dictionary of headers and their dependencies, or 'dot' for a Graphvis
    directed graph.
  --pretty-dot
    This is a shortcut for '--pretty-names --out-format dot'.
  --parallel <processes>
    Use a number of parser processes equal to the positive number <processes>.
    The default is 8. This does not include the preprocessor processes.
  --pp-argv
    After this comes the argument vector of the preprocessor ('cc -E' by
    default) terminated by a '--'. After this come the input files, not more
    options.
  --help
    Display help text.
  --version
    Display version.
EOT

sub fatal {
    say STDERR "$program_name: @_";
    exit 1;
}

sub start_preprocessor {
    my ( $argv, $file ) = @_;
    my $argv_esc = join ' ', ( map { shell_escape($_) } @$argv );
    $file = "./$file" if ( $file =~ /^-/ );
    my $file_esc = shell_escape($file);
    if ( open( my $pp_out, '-|', "$argv_esc $file_esc | fgrep '#'" ) ) {
        return $pp_out;
    }
}

sub shell_escape {
    local ($_) = @_;
    local ($0);
    s/'/'\\''/g;
    return "'$_'";
}

sub json_escape {
    local ($_) = @_;
    local ($0);
    s/(["\\])/\\$1/g;
    s/\x08/\\b/g;
    s/\f/\\f/g;
    s/\n/\\n/g;
    s/\r/\\r/g;
    s/\t/\\t/g;
    s/([\x00-\x1F\x80-\xFF])/sprintf "\\u%04x", ord(+$1)/eg;
    return "\"$_\"";
}

sub dot_escape {
    local ($_) = @_;
    local ($0);

    # Backslashes cannot be escaped; remove a final one as a last resort:
    s/\\$//;
    s/"/\\"/g;
    return "\"$_\"";
}

sub c_unescape {
    local ($_) = @_;
    return "$_" if ( !/\\/ );
    local ( $0, $1, $2, $3, $4 );
    s/\\a/\a/g;
    s/\\b/\x08/g;
    s/\\e/\e/g;
    s/\\f/\f/g;
    s/\\n/\n/g;
    s/\\r/\r/g;
    s/\\t/\t/g;
    s/\\v/\x0B/g;
    s/\\'/'/g;
    s/\\"/"/g;
    s/\\\?/?/g;
s/\\([0-3]?[0-7]{1,2})|\\x([0-9a-fA-F]{1,2})|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{8})|\\\\/
        defined($1) ? chr(oct($1)) :
        defined($2) ? chr(hex($2)) :
        defined($3) ? chr(hex($3)) :
	defined($4) ? chr(hex($4)) :
                      '\\'
    /eg;
    return "$_";
}

sub header_label {
    my ($path) = @_;
    local ( $0, $1 );
    if ( $path =~ /include\/+(.+)$/ ) {
        return "<$1>";
    }
    elsif ( $path =~ /\/([^\/]+)$/ ) {
        return "\"$1\"";
    }
    return "\"$path\"";
}

sub parse_file_spec {
    my ($line) = @_;
    local ( $0, $1, $2, $3, $4, $5, $6 );
    if ( $line =~ /^# ([0-9]+) "(.+)"( 1)?( 2)?( 3)?( 4)?$/ ) {
        my $linenum  = +$1;
        my $filename = c_unescape($2);
        my $flags    = 0;
        if ($3) {
            $flags |= INCFLAG_INCLUDE_FILE;
        }
        if ($4) {
            $flags |= INCFLAG_RETURN_TO_FILE;
        }
        if ($5) {
            $flags |= INCFLAG_SYSTEM_HEADER;
        }
        if ($6) {
            $flags |= INCFLAG_EXTERN_C;
        }
        return ( $linenum, $filename, $flags );
    }
}

sub parse_next_pp_line {
    my ($pp_out) = @_;
    while ( my $pp_out_line = <$pp_out> ) {
        my @line = parse_file_spec($pp_out_line);
        if ( $line[0] ) {
            return @line;
        }
    }
}

sub skip_to_end {
    my $depth = 0;
    while ( $depth >= 0 ) {
        my ( $linenum, $filename, $flags ) = parse_next_pp_line(@_);
        return if ( !$linenum );
        if ( $flags & INCFLAG_INCLUDE_FILE ) {
            ++$depth;
        }
        elsif ( $flags & INCFLAG_RETURN_TO_FILE ) {
            --$depth;
        }
    }
}

sub is_foreign_path {
    my ( $path, $local_dir ) = @_;
    return ( substr $path, 0, 1 ) eq '/'
      && ( substr $path, 0, length $local_dir ) ne $local_dir;
}

sub scan_dependencies {
    my ( $deps, $pp_out, $track_system, $local_dir ) = @_;
    my ( $num1, $this_file ) = parse_next_pp_line($pp_out);
    return if $num1 != 1;
    my $these_deps = {};
    $deps->{$this_file} = $these_deps;
    for ( ; ; ) {
        my ( $linenum, $filename, $flags ) = parse_next_pp_line($pp_out);
        return if !$linenum;
        if ( $flags & INCFLAG_INCLUDE_FILE ) {
            if (
                !$track_system
                && ( ( $flags & INCFLAG_SYSTEM_HEADER )
                    || is_foreign_path( $filename, $local_dir ) )
              )
            {
                skip_to_end($pp_out);
            }
            else {
                $this_file               = $filename;
                $these_deps->{$filename} = 1;
                $these_deps              = $deps->{$filename};
                if ( !$these_deps ) {
                    $these_deps = {};
                    $deps->{$this_file} = $these_deps;
                }
            }
        }
        elsif ( $flags & INCFLAG_RETURN_TO_FILE ) {
            $this_file  = $filename;
            $these_deps = $deps->{$this_file};
        }
    }
}

sub trim_dependencies {
    my ( $deps, $remove_builtin ) = @_;
    if ($remove_builtin) {
        delete $deps->{'<built-in>'};
        delete $deps->{'<command line>'};
    }
}

sub write_dependencies {
    my ( $deps, $file ) = @_;
    while ( my ( $filename, $deps ) = each %$deps ) {
        print $file $filename, "\0";
        foreach my $dep ( keys %$deps ) {
            print $file $dep, "\0";
        }
        print $file "\0";
    }
}

sub read_dependencies {
    my ( $file, $deps ) = @_;
    while ( length( my $path = read_path($file) ) ) {
        my $these_deps = $deps->{$path};
        if ( !$these_deps ) {
            $these_deps = {};
            $deps->{$path} = $these_deps;
        }
        while ( length( my $depname = read_path($file) ) ) {
            $these_deps->{$depname} = 1;
        }
    }
}

sub read_path {
    my ($file) = @_;
    my $path = '';
    while ( ( read $file, my $buf, 1 ) == 1 ) {
        last if ( $buf eq "\0" );
        $path .= $buf;
    }
    return $path;
}

sub print_dependencies {
    my ( $deps, $pretty_names, $fmt ) = @_;
    if ( $fmt eq 'json' ) {
        print '{';
        my $before = '';
        while ( my ( $filename, $these_deps ) = each %$deps ) {
            print $before, json_escape($filename), ':[';
            $before = ',';
            my $before = '';
            foreach my $depname ( keys %$these_deps ) {
                if ( $deps->{$depname} ) {
                    print $before, json_escape($depname);
                    $before = ',';
                }
            }
            print ']';
        }
        print '}';
    }
    elsif ( $fmt eq 'dot' ) {
        my %node_names = ();
        print "digraph deps {\n";
        my $i = 0;
        foreach my $filename ( keys %$deps ) {
            my $label =
              dot_escape( $pretty_names ? header_label($filename) : $filename );
            $node_names{$filename} = "n$i";
            print "    n$i [label=$label];\n";
            ++$i;
        }
        while ( my ( $filename, $deps ) = each %$deps ) {
            my $this_node = $node_names{$filename};
            foreach my $dep_name ( keys %$deps ) {
                my $dep_node = $node_names{$dep_name};
                print "    $this_node -> $dep_node;\n" if ($dep_node);
            }
        }
        print "}\n";
    }
}

main()
