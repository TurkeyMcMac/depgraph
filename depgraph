#!/usr/bin/env perl

use strict;
use warnings;

use constant INCFLAG_INCLUDE_FILE   => 1;
use constant INCFLAG_RETURN_TO_FILE => 2;
use constant INCFLAG_SYSTEM_HEADER  => 4;
use constant INCFLAG_EXTERN_C       => 8;

sub main {
    my %deps                = ();
    my $opt_track_system    = 1;
    my $opt_local_dir       = './';
    my $opt_remove_built_in = 1;
    my $opt_pretty_names    = 0;
    my $opt_out_format      = 'json';
    for my $file (@ARGV) {
        ( my $pp_out = start_preprocessor($file) )
          or die "Unable to start preprocessor; $!";
        scan_dependencies( \%deps, $pp_out, $opt_track_system, $opt_local_dir );
    }
    trim_dependencies( \%deps, $opt_remove_built_in );
    print_dependencies( \%deps, $opt_pretty_names, $opt_out_format );
}

sub start_preprocessor {
    my ($file) = @_;
    if ( open( my $pp_out, '-|', "cc -E $file | fgrep '#'" ) ) {
        return $pp_out;
    }
}

sub header_label {
    my ($path) = @_;
    local ( $0, $1 );
    if ( $path =~ /include\/+(.+)$/ ) {
        return "<$1>";
    }
    elsif ( $path =~ /\/([^\/]+)$/ ) {
        return "\\\"$1\\\"";
    }
    return "\\\"$path\\\"";
}

sub parse_file_spec {
    my ($line) = @_;
    local ( $0, $1, $2, $3, $4, $5, $6 );

    # TODO: unordered flags? Flexible whitespace?
    if ( $line =~ /^# ([0-9]+) "([^"]+)"( 1)?( 2)?( 3)?( 4)?$/ ) {
        my $linenum  = +$1;
        my $filename = $2;
        my $flags    = 0;
        if ($3) {
            $flags |= INCFLAG_INCLUDE_FILE;
        }
        if ($4) {
            $flags |= INCFLAG_RETURN_TO_FILE;
        }
        if ($5) {
            $flags |= INCFLAG_SYSTEM_HEADER;
        }
        if ($6) {
            $flags |= INCFLAG_EXTERN_C;
        }
        return ( $linenum, $filename, $flags );    # TODO: unescape $filename
    }
}

sub parse_next_pp_line {
    my ($pp_out) = @_;
    while ( my $pp_out_line = <$pp_out> ) {
        my @line = parse_file_spec($pp_out_line);
        if ( $line[0] ) {
            return @line;
        }
    }
}

sub skip_to_end {
    my $depth = 0;
    while ( $depth >= 0 ) {
        my ( $linenum, $filename, $flags ) = parse_next_pp_line(@_);
        return if ( !$linenum );
        if ( $flags & INCFLAG_INCLUDE_FILE ) {
            ++$depth;
        }
        elsif ( $flags & INCFLAG_RETURN_TO_FILE ) {
            --$depth;
        }
    }
}

sub is_foreign_path {
    my ( $path, $local_dir ) = @_;
    return ( substr $path, 0, 1 ) eq '/'
      && ( substr $path, 0, length $local_dir ) ne $local_dir;
}

sub scan_dependencies {
    my ( $deps, $pp_out, $track_system, $local_dir ) = @_;
    my ( $num1, $this_file ) = parse_next_pp_line($pp_out);
    return if $num1 != 1;
    my $these_deps = {};
    $deps->{$this_file} = $these_deps;
    for ( ; ; ) {
        my ( $linenum, $filename, $flags ) = parse_next_pp_line($pp_out);
        return if !$linenum;
        if ( $flags & INCFLAG_INCLUDE_FILE ) {
            if (
                !$track_system
                && ( ( $flags & INCFLAG_SYSTEM_HEADER )
                    || is_foreign_path( $filename, $local_dir ) )
              )
            {
                skip_to_end($pp_out);
            }
            else {
                $this_file               = $filename;
                $these_deps->{$filename} = 1;
                $these_deps              = $deps->{$filename};
                if ( !$these_deps ) {
                    $these_deps = {};
                    $deps->{$this_file} = $these_deps;
                }
            }
        }
        elsif ( $flags & INCFLAG_RETURN_TO_FILE ) {
            $this_file  = $filename;
            $these_deps = $deps->{$this_file};
        }
    }
}

sub trim_dependencies {
    my ( $deps, $remove_builtin ) = @_;
    if ($remove_builtin) {
        delete $deps->{'<built-in>'};
        delete $deps->{'<command line>'};
    }
}

sub print_dependencies {
    my ( $deps, $pretty_names, $fmt ) = @_;

    # TODO: escape names
    if ( $fmt eq 'json' ) {
        print '{';
        my $before = '';
        while ( my ( $filename, $these_deps ) = each %$deps ) {
            print "$before\"$filename\":[";
            $before = ',';
            my $before = '';
            foreach my $depname ( keys %$these_deps ) {
                if ( $deps->{$depname} ) {
                    print "$before\"$depname\"";
                    $before = ',';
                }
            }
            print ']';
        }
        print '}';
    }
    elsif ( $fmt eq 'dot' ) {
        my %node_names = ();
        print "digraph deps {\n";
        my $i = 0;
        foreach my $filename ( keys %$deps ) {
            my $label = $pretty_names ? header_label($filename) : $filename;
            $node_names{$filename} = "n$i";
            print "    n$i [label=\"$label\"];\n";    # TODO: escape label
            ++$i;
        }
        while ( my ( $filename, $deps ) = each %$deps ) {
            my $this_node = $node_names{$filename};
            foreach my $dep_name ( keys %$deps ) {
                my $dep_node = $node_names{$dep_name};
                print "    $this_node -> $dep_node;\n" if ($dep_node);
            }
        }
        print "}\n";
    }
}

main()
