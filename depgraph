#!/usr/bin/env perl

use strict;
use warnings;

use constant INCFLAG_INCLUDE_FILE   => 1;
use constant INCFLAG_RETURN_TO_FILE => 2;
use constant INCFLAG_SYSTEM_HEADER  => 4;
use constant INCFLAG_EXTERN_C       => 8;

my $program_name = $0;

sub main {
    my $opt_track_system    = 0;
    my $opt_local_dir       = '.';
    my $opt_remove_built_in = 1;
    my $opt_pretty_names    = 0;
    my $opt_out_format      = 'json';
    my @opt_pp_argv         = ( 'cc', '-E' );
    while ( $#ARGV >= 0 ) {
        local ( $0, $1 );
        my $arg = shift @ARGV;
        if ( $arg eq '--track-system' ) {
            $opt_track_system = 1;
        }
        elsif ( $arg eq '--no-track-system' ) {
            $opt_track_system = 0;
        }
        elsif ( $arg eq '--local-dir' ) {
            fatal('Option --local-dir requires an argument') if ( $#ARGV < 0 );
            $opt_local_dir = shift @ARGV;
        }
        elsif ( $arg =~ /^--local-dir=(.*)$/ ) {
            $opt_local_dir = $1;
        }
        elsif ( $arg eq '--remove-built-in' ) {
            $opt_remove_built_in = 1;
        }
        elsif ( $arg eq '--no-remove-built-in' ) {
            $opt_remove_built_in = 0;
        }
        elsif ( $arg eq '--pretty-names' ) {
            $opt_pretty_names = 1;
        }
        elsif ( $arg eq '--no-pretty-names' ) {
            $opt_pretty_names = 0;
        }
        elsif ( $arg eq '--out-format' ) {
            fatal('Option --out-format requires an argument') if ( $#ARGV < 0 );
            $opt_out_format = shift @ARGV;
        }
        elsif ( $arg =~ /^--out-format=(.*)$/ ) {
            $opt_out_format = $1;
        }
        elsif ( $arg eq '--pp-argv' ) {
            @opt_pp_argv = ();
            while ( $#ARGV >= 0 && ( $arg = shift @ARGV ) ne '--' ) {
                push @opt_pp_argv, $arg;
            }
            last;
        }
        elsif ( $arg eq '--' ) {
            last;
        }
        elsif ( $arg =~ /^-./ ) {
            fatal("Unknown option: $arg");
        }
        else {
            unshift @ARGV, $arg;
            last;
        }
    }
    $opt_local_dir .= '/';

    my %deps = ();
    for my $file (@ARGV) {
        ( my $pp_out = start_preprocessor( \@opt_pp_argv, $file ) )
          or fatal("Unable to start preprocessor; $!");
        scan_dependencies( \%deps, $pp_out, $opt_track_system, $opt_local_dir );
    }
    trim_dependencies( \%deps, $opt_remove_built_in );
    print_dependencies( \%deps, $opt_pretty_names, $opt_out_format );
}

sub fatal {
    say STDERR "$program_name: @_";
    exit 1;
}

sub start_preprocessor {
    my ( $argv, $file ) = @_;
    my $argv_esc = join ' ', ( map { shell_escape($_) } @$argv );
    my $file_esc = shell_escape($file);
    if ( open( my $pp_out, '-|', "$argv_esc $file_esc | fgrep '#'" ) ) {
        return $pp_out;
    }
}

sub shell_escape {
    local ($_) = @_;
    local ($0);
    s/'/'\\''/g;
    return "'$_'";
}

sub c_unescape {
    local ($_) = @_;
    return "$_" if ( !/\\/ );
    local ( $0, $1, $2, $3, $4 );
    s/^"(.*)"$/$1/;
    s/\\a/\a/g;
    s/\\b/\b/g;
    s/\\e/\e/g;
    s/\\f/\f/g;
    s/\\n/\n/g;
    s/\\r/\r/g;
    s/\\t/\t/g;
    s/\\v/\x0B/g;
    s/\\'/'/g;
    s/\\"/"/g;
    s/\\\?/?/g;
s/\\([0-3]?[0-7]{1,2})|\\x([0-9a-fA-F]{1,2})|\\u([0-9a-fA-F]{4})|\\U([0-9a-fA-F]{8})|\\\\/
        defined($1) ? chr(oct($1)) :
        defined($2) ? chr(hex($2)) :
        defined($3) ? chr(hex($3)) :
	defined($4) ? chr(hex($4)) :
                      '\\'
    /eg;
    return "$_";
}

sub header_label {
    my ($path) = @_;
    local ( $0, $1 );
    if ( $path =~ /include\/+(.+)$/ ) {
        return "<$1>";
    }
    elsif ( $path =~ /\/([^\/]+)$/ ) {
        return "\\\"$1\\\"";
    }
    return "\\\"$path\\\"";
}

sub parse_file_spec {
    my ($line) = @_;
    local ( $0, $1, $2, $3, $4, $5, $6 );
    if ( $line =~ /^# ([0-9]+) "(.+)"( 1)?( 2)?( 3)?( 4)?$/ ) {
        my $linenum  = +$1;
        my $filename = c_unescape($2);
        my $flags    = 0;
        if ($3) {
            $flags |= INCFLAG_INCLUDE_FILE;
        }
        if ($4) {
            $flags |= INCFLAG_RETURN_TO_FILE;
        }
        if ($5) {
            $flags |= INCFLAG_SYSTEM_HEADER;
        }
        if ($6) {
            $flags |= INCFLAG_EXTERN_C;
        }
        return ( $linenum, $filename, $flags );    # TODO: unescape $filename
    }
}

sub parse_next_pp_line {
    my ($pp_out) = @_;
    while ( my $pp_out_line = <$pp_out> ) {
        my @line = parse_file_spec($pp_out_line);
        if ( $line[0] ) {
            return @line;
        }
    }
}

sub skip_to_end {
    my $depth = 0;
    while ( $depth >= 0 ) {
        my ( $linenum, $filename, $flags ) = parse_next_pp_line(@_);
        return if ( !$linenum );
        if ( $flags & INCFLAG_INCLUDE_FILE ) {
            ++$depth;
        }
        elsif ( $flags & INCFLAG_RETURN_TO_FILE ) {
            --$depth;
        }
    }
}

sub is_foreign_path {
    my ( $path, $local_dir ) = @_;
    return ( substr $path, 0, 1 ) eq '/'
      && ( substr $path, 0, length $local_dir ) ne $local_dir;
}

sub scan_dependencies {
    my ( $deps, $pp_out, $track_system, $local_dir ) = @_;
    my ( $num1, $this_file ) = parse_next_pp_line($pp_out);
    return if $num1 != 1;
    my $these_deps = {};
    $deps->{$this_file} = $these_deps;
    for ( ; ; ) {
        my ( $linenum, $filename, $flags ) = parse_next_pp_line($pp_out);
        return if !$linenum;
        if ( $flags & INCFLAG_INCLUDE_FILE ) {
            if (
                !$track_system
                && ( ( $flags & INCFLAG_SYSTEM_HEADER )
                    || is_foreign_path( $filename, $local_dir ) )
              )
            {
                skip_to_end($pp_out);
            }
            else {
                $this_file               = $filename;
                $these_deps->{$filename} = 1;
                $these_deps              = $deps->{$filename};
                if ( !$these_deps ) {
                    $these_deps = {};
                    $deps->{$this_file} = $these_deps;
                }
            }
        }
        elsif ( $flags & INCFLAG_RETURN_TO_FILE ) {
            $this_file  = $filename;
            $these_deps = $deps->{$this_file};
        }
    }
}

sub trim_dependencies {
    my ( $deps, $remove_builtin ) = @_;
    if ($remove_builtin) {
        delete $deps->{'<built-in>'};
        delete $deps->{'<command line>'};
    }
}

sub print_dependencies {
    my ( $deps, $pretty_names, $fmt ) = @_;

    # TODO: escape names
    if ( $fmt eq 'json' ) {
        print '{';
        my $before = '';
        while ( my ( $filename, $these_deps ) = each %$deps ) {
            print "$before\"$filename\":[";
            $before = ',';
            my $before = '';
            foreach my $depname ( keys %$these_deps ) {
                if ( $deps->{$depname} ) {
                    print "$before\"$depname\"";
                    $before = ',';
                }
            }
            print ']';
        }
        print '}';
    }
    elsif ( $fmt eq 'dot' ) {
        my %node_names = ();
        print "digraph deps {\n";
        my $i = 0;
        foreach my $filename ( keys %$deps ) {
            my $label = $pretty_names ? header_label($filename) : $filename;
            $node_names{$filename} = "n$i";
            print "    n$i [label=\"$label\"];\n";    # TODO: escape label
            ++$i;
        }
        while ( my ( $filename, $deps ) = each %$deps ) {
            my $this_node = $node_names{$filename};
            foreach my $dep_name ( keys %$deps ) {
                my $dep_node = $node_names{$dep_name};
                print "    $this_node -> $dep_node;\n" if ($dep_node);
            }
        }
        print "}\n";
    }
}

main()
